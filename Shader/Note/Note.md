# Unity Shader 笔记

## GPU流水线

### GPU渲染流程图

![GPU渲染流程](./images/GPU%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png)
>▲颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由GPU固定实现的，开发者没有任何控制权。实线表示该Shader必须由开发者编程实现，虚线表示该Shader是可选的

### 顶点着色器（Vertex Shader）

顶点着色器需要完成的工作主要有： **[坐标变换](#坐标变换)** 和 **[逐顶点光照](#逐顶点光照)** 。

#### 坐标变换

一个最基本的顶点着色器必须完成的一个工作是： **把顶点坐标从模型空间转换到齐次裁剪空间** 。

##### 这是 Unity 标准渲染管线中的部分代码

```cpp
#include "UnityCG.cginc"

// 标准写法
o.pos = mul(UNITY_MVP，v.position);

// 更高效的写法
o.pos = mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(v.position, 1.0)));

// 直接调用 Unity 函数
o.pos = UnityObjectToClipPos(v.position)
```

##### 这是 Unity URP 中的部分代码

```cpp
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

o.pos = TransformObjectToHClip(v.position);
```

#### 逐顶点光照

***Todo***: 待学习

### 裁剪（Clipping）

![裁剪示意图](./images/%E8%A3%81%E5%89%AA%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
>▲只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元（红色三角形）被舍弃，完全在单位立方体内部的图（绿色三角形）将被保留。和单位立方体相交的图元（黄色三角形）会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃。

**裁剪** 是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。

### 屏幕映射（Screen Mapping）

屏幕映射（Screen Mapping）的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。\
**注意** OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则定义了屏幕的左上角为最小的窗口坐标值。

### 三角形设置（Triangle Setup）

这个阶段会计算光栅化一个三角网格所需的信息。它的输出是为了给下一个阶段做准备。

### 三角形遍历（Triangle Traversal）

这个阶段将会检查每个 **像素** 是否被一个三角网格所覆盖。如果被覆盖的话，就会生成一个 **片元**（fragment）。
而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换（Scan Conversion）

![三角形遍历](./images/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86.png)
>▲根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对3个顶点的信息进行插值得到的。例如，上图中3个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0

这一步的输出就是得到一个片元序列。需要注意的是，一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了（但不限于）它的屏幕坐标、深度信息，以及其他从几何阶段输出的顶点信息，例如法线、纹理坐标等。

### 片元着色器（Fragment Shader）

在DirectX中，片元着色器被称为像素着色器（Pixel Shader）。\
片元着色器的输入是上一个阶段对顶点信息插值得到的结果，更具体来说，是根据那些从顶点着色器中输出的数据插值得到的。而它的输出是一个或者多个颜色值。\
这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。为了在片元着色器中进行纹理采样，我们通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标了。\
它的局限在于，它仅可以影响单个片元。也就是说，当执行片元着色器时，它不可以将自己的任何结果直接发送给它的邻居们。\
***Todo***: 完成纹理采样相关的学习。

### 逐片元操作

逐片元操作（Per-Fragment Operations）是OpenGL中的说法，在DirectX中，这一阶段被称为输出合并阶段（Output-Merger）。\
这一阶段有几个主要任务。\
（1）决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等。\
（2）如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。\

## 名词解释

### NDC

归一化的设备坐标（Normalized Device Coordinates）

### Early-Z技术

作为一个想充分提高性能的GPU，它会希望尽可能早地知道哪些片元是会被舍弃的，对于这些片元就不需要再使用片元着色器来计算它们的颜色。\
在Unity给出的渲染流水线中，我们也可以发现它给出的深度测试是在片元着色器之前。这种将深度测试提前执行的技术通常也被称为Early-Z技术。

### HLSL

DirectX的 HLSL（High Level Shading Language）\
由微软控制着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的（前提是版本相同）。但也因此支持HLSL的平台相对比较有限，几乎完全是微软自已的产品。这是因为在其他平台上没有可以编译HLSL的编译器。

### GLSL

OpenGL的GLSL（OpenGL Shading Language）\
GLSL的优点在于它的跨平台性，，但这种跨平台性是由于OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作。换句话说，GLSL是依赖硬件，而非操作系统层级的。但这也意味着GLSL的编译结果将取决于硬件供应商，他们对GLSL的编译实现不尽相同，这可能会造成编译结果不一致的情况，因为这完全取决于供应商的做法。

### CG

NVIDIA的CG（C for Graphic）\
CG是真正意义上的跨平台。它会根据平台的不同，编译成相应的中间语言。CG语言的跨平台性很大原因取决于与微软的合作，这也导致CG语言的语法和HLSL非常相像，CG语言可以无缝移植成HLSL代码。但缺点是可能无法完全发挥出OpenGL的最新特性。

### Batching

批处理（Batching）\
就是把很多小的DrawCall合并成一个大的Draw Call

<link rel="stylesheet" type="text/css" href="auto_number_title.css"/>
